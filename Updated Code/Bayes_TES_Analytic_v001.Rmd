---
title: "Parallel Processing"
author: "Veronica"
date: "2025-06-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{r cars}
library(rJava)
library(gtools)
library(readxl)
library(coda)
library(future)
library(future.apply)
library(abind)
library(gtools)
library(readxl)
library(kableExtra)
```


# User defined input

```{r}
# Define the number of chains you want to run
n_chains <- 4 

#  Automated MCMC Control Parameters
R_hat_threshold <- 1.01
ESS_threshold <- 400
chunk_size <- 2000
max_iterations <- 10000
burn_in_frac <- 0.25

# this is the size of the repeat region for each microsatellite (ie. for dimers use 2, for trimers use 3)
locirepeats = c(2,2,3,3,3,3,3)

# this is the tolerance for each marker, used during match counting
bin_sizes = c(0,0,0,0,0,0,0)
```


# Data importation and cleaning for Bayesian

```{r pressure, echo=FALSE}
# input file
inputfile = "Angola_2021_TES_7NMS.xlsx"

### IMPORT
options(java.parameters = "-Xmx4096m")


##### read in data
genotypedata_latefailures = as.data.frame(read_excel(inputfile, sheet = "Late Treatment Failures",skip=3))
  
# missing data has to be coded as NA
genotypedata_latefailures[genotypedata_latefailures == 0] = NA
genotypedata_latefailures[genotypedata_latefailures == "0"] = NA 
genotypedata_latefailures[genotypedata_latefailures == "N/A"] = NA 
genotypedata_latefailures[genotypedata_latefailures == "-"] = NA 
genotypedata_latefailures[genotypedata_latefailures == "NA"] = NA 

### recode sample names so that each pair has a " Day 0" and a " Day Failure"
genotypedata_latefailures$Sample.ID = sub("D0$"," Day 0",genotypedata_latefailures$Sample.ID)
genotypedata_latefailures$Sample.ID = sub("D[0-9]+$"," Day Failure",genotypedata_latefailures$Sample.ID)


# each sample in genotypedata_RR has to have day 0 and day of Failure
ids = unique(unlist(strsplit(genotypedata_latefailures$Sample.ID[grepl("Day 0",genotypedata_latefailures$Sample.ID)]," Day 0")))
if (sum(!paste(ids, "Day Failure") %in% genotypedata_latefailures$Sample.ID) > 0) {
	print("Error - each sample must have day 0 and day of failure data")
}
ids = unique(unlist(strsplit(genotypedata_latefailures$Sample.ID[grepl("Day Failure",genotypedata_latefailures$Sample.ID)]," Day Failure")))
if (sum(!paste(ids, "Day 0") %in% genotypedata_latefailures$Sample.ID) > 0) {
	print("Error - each sample must have day 0 and day of failure data")
}

### background samples (from "Additional" tab)
  additional_genotypedata = as.data.frame(read_excel(inputfile, sheet = "Additional",skip=3))
  if (dim(additional_genotypedata)[1] > 0) { 
    # missing data has to be coded as NA
    additional_genotypedata[additional_genotypedata == 0] = NA 
    additional_genotypedata[additional_genotypedata == "0"] = NA
    additional_genotypedata[additional_genotypedata == "N/A"] = NA
    additional_genotypedata[additional_genotypedata == "-"] = NA
    additional_genotypedata[additional_genotypedata == "NA"] = NA
    additional_genotypedata$Sample.ID = sub("_D0"," Day 0",additional_genotypedata$Sample.ID)
    additional_genotypedata$Sample.ID = sub("_D[0-9]*"," Day Failure",additional_genotypedata$Sample.ID)
  }
  
  # recode as numeric
  genotypedata_latefailures[,colnames(genotypedata_latefailures)[-c(1,2)]] = sapply(colnames(genotypedata_latefailures)[-c(1,2)],function (x) as.numeric(as.character(genotypedata_latefailures[,x])))
  additional_genotypedata[,colnames(additional_genotypedata)[-c(1,2)]] = sapply(colnames(additional_genotypedata)[-c(1,2)],function (x) as.numeric(as.character(additional_genotypedata[,x])))
```


# Bayesian approach functions

```{r}
# Recode allele function
recodeallele = function(alleles_definitions_subset,proposed) {
	
	ret = which(proposed > alleles_definitions_subset[,1] & proposed <= alleles_definitions_subset[,2])
	if (length(ret) == 0) {
		ret = NA
	}
	ret
}

recode_alleles = function(genotypedata, alleles_definitions) {

########### generate MOI for each sample

ids = unique(unlist(strsplit(genotypedata$Sample.ID[grepl("Day 0",genotypedata$Sample.ID)]," Day 0")))
locinames = unique(sapply(colnames(genotypedata)[-1],function(x) strsplit(x,"_")[[1]][1]))
nids = length(ids)
nloci = length(locinames)


MOI0 = rep(0,nids)
MOIf = rep(0,nids)

# for each individual, cycle through each locus and count number of separate alleles

for (i in 1:nids) {
	for (j in 1:nloci) {
		locicolumns = grepl(paste(locinames[j],"_",sep=""),colnames(genotypedata))
		nalleles0 = sum(!is.na(genotypedata[grepl(paste(ids[i],"Day 0"),genotypedata$Sample.ID),locicolumns]))
		nallelesf = sum(!is.na(genotypedata[grepl(paste(ids[i],"Day Failure"),genotypedata$Sample.ID),locicolumns]))

		MOI0[i] = max(MOI0[i],nalleles0)
		MOIf[i] = max(MOIf[i],nallelesf)
	}
}


observeddatamatrix = list()
  for (j in 1:nloci) { 
    locus = locinames[j]
    # Use more robust pattern matching for column names
    locus_allele_cols_pattern = paste0("^", locus, "_") # Match from the beginning of the name
    locicolumns_logical = grepl(locus_allele_cols_pattern, colnames(genotypedata))

    current_locus_raw_df = genotypedata[, locicolumns_logical, drop = FALSE]
    
    raw_allele_values_matrix_locus_j = matrix(numeric(0), 
                                              nrow = nrow(genotypedata), 
                                              ncol = ncol(current_locus_raw_df)) # Pre-allocate

    if (ncol(current_locus_raw_df) > 0) {
        for(col_idx in 1:ncol(current_locus_raw_df)){
            raw_allele_values_matrix_locus_j[,col_idx] = as.numeric(as.character(current_locus_raw_df[[col_idx]]))
        }
    }
    
    newalleles_recoded_matrix = matrix(NA_integer_, # Store recoded integers or NA
                                       nrow = nrow(raw_allele_values_matrix_locus_j), 
                                       ncol = ncol(raw_allele_values_matrix_locus_j))

    if (ncol(raw_allele_values_matrix_locus_j) > 0) { # Only proceed if there are allele columns
      for (k_col_idx in 1:ncol(raw_allele_values_matrix_locus_j)) {   # Iterate over allele columns (e.g., _1, _2, _3)
        for (i_row_idx in 1:nrow(raw_allele_values_matrix_locus_j)) { # Iterate over samples in genotypedata
          
          proposed_value = raw_allele_values_matrix_locus_j[i_row_idx, k_col_idx]
          
          if (!is.na(proposed_value)) {
            
            newalleles_recoded_matrix[i_row_idx, k_col_idx] = recodeallele(
              alleles_definitions_subset = alleles_definitions[[j]], # Pass the definitions for current locus j
              proposed = proposed_value
            )
          } else {
            newalleles_recoded_matrix[i_row_idx, k_col_idx] = NA # Keep NA as NA
          }
        }
      }
    }
   
    tempobservedata = character(nids) # Pre-allocate for efficiency

    for (i_patient_idx in 1:nids) { # Inner loop over unique patient IDs (1 to nids)
      patient_id_str = ids[i_patient_idx] # Get the actual patient ID string
      
      day0_logical_idx = genotypedata$Sample.ID == paste(patient_id_str, "Day 0")
      dayf_logical_idx = genotypedata$Sample.ID == paste(patient_id_str, "Day Failure")

      day0_recoded_alleles_for_patient_locus = newalleles_recoded_matrix[day0_logical_idx, , drop = FALSE]
      day0_unique_sorted = sort(unique(day0_recoded_alleles_for_patient_locus[!is.na(day0_recoded_alleles_for_patient_locus)]))

      dayf_recoded_alleles_for_patient_locus = newalleles_recoded_matrix[dayf_logical_idx, , drop = FALSE]
      dayf_unique_sorted = sort(unique(dayf_recoded_alleles_for_patient_locus[!is.na(dayf_recoded_alleles_for_patient_locus)]))
      
      day0_str = paste(day0_unique_sorted, collapse = "-")
      dayf_str = paste(dayf_unique_sorted, collapse = "-")
      
      if (length(day0_unique_sorted) == 0) day0_str = ""
      if (length(dayf_unique_sorted) == 0) dayf_str = ""

      tempobservedata[i_patient_idx] = paste(day0_str, dayf_str, sep = "/")
    }
    observeddatamatrix[[j]] = tempobservedata
  }




MOItemp = cbind(MOI0,MOIf)
rownames(MOItemp) = ids
list(observeddatamatrix = observeddatamatrix, MOI = MOItemp)
}

findposteriorfrequencies = function(locus_index, tempdata, maxMOI, frequencies_RR) {
	data = tempdata[,c(1:maxMOI)+(locus_index-1)*maxMOI];
	nalleles = frequencies_RR[[1]][locus_index]
	freq_prior_alpha = rep(1,nalleles);
	freq_posterior_alpha = freq_prior_alpha + table(factor(c(data),levels=c(1:nalleles)));
	frequencies_RR[[2]][locus_index, 1:nalleles] <- gtools::rdirichlet(1, freq_posterior_alpha);
	
  return(frequencies_RR)
}


define_alleles = function(genotypedata, locirepeats, maxk) {
	
ids = genotypedata$Sample.ID

locinames = unique(sapply(colnames(genotypedata)[-1],function(x) strsplit(x,"_")[[1]][1]))

nids = length(ids)
nloci = length(locinames)

#windows(16,8)
#par(mfrow = c(2,ceiling(nloci/2)))
alleles = list()
observed_data = list()
for (j in 1:nloci) {
	locicolumns = grepl(paste(locinames[j],"_",sep=""),colnames(genotypedata))
	raw_alleles = c(as.matrix(genotypedata[,locicolumns]))
	raw_alleles = raw_alleles[!is.na(raw_alleles)]
	
	if (diff(range(raw_alleles)) < locirepeats[j]) {
		alleles[[j]] = matrix(c(min(raw_alleles)-locirepeats[j]/2,max(raw_alleles)+locirepeats[j]/2,length(raw_alleles)),1,3)
	} else {
	

	breaks = seq(from = floor(min(raw_alleles))-0.5, to = (max(raw_alleles)+1), by = 1)
	allele_values = round((breaks[2:length(breaks)] + breaks[1:(length(breaks)-1)]) / 2)
	hist_alleles = hist(raw_alleles, breaks = breaks, plot = FALSE)


	counts_by_offset = sapply(1:locirepeats[j], function (x) sum(hist_alleles$counts[seq(from = x, to = length(hist_alleles$counts), by = locirepeats[j])]))
	possible_alleles = allele_values[seq(from = which.max(counts_by_offset), to = length(allele_values), by = locirepeats[j])]

	if (min(raw_alleles) <= (min(possible_alleles)-locirepeats[j]/2)) {
		possible_alleles = c(min(possible_alleles-locirepeats[j]),possible_alleles)
	}
	if (max(raw_alleles) > (max(possible_alleles)+locirepeats[j]/2)) {
		possible_alleles = c(possible_alleles,max(possible_alleles+locirepeats[j]))
	}

	# assign clusters
	clusters = sapply(raw_alleles, function (x) which.min(abs(possible_alleles - x)))
	k = length(unique(clusters))
	
	colv = rep("white",length(possible_alleles))
	colv[1:length(possible_alleles) %in% unique(clusters)] = rainbow(k)
	
	lower_break_value = sort(possible_alleles[unique(clusters)] - locirepeats[j]/2)
	upper_break_value = sort(possible_alleles[unique(clusters)] + locirepeats[j]/2)
	counts = sapply(1:length(lower_break_value), function (x) sum(raw_alleles > lower_break_value[x] & raw_alleles <= upper_break_value[x]))
	alleles[[j]] = cbind(lower_break_value, upper_break_value, counts)
	}
}
	
#### compress
# take maxk most frequent alleles

alleles2 = list()
for (j in 1:nloci) {
	sortedindex = sort.int(alleles[[j]][,3],decreasing = TRUE,index.return = TRUE)$ix[1:maxk[j]]
	if (length(alleles[[j]][,3]) <= maxk[j]) {
		sortedindex = sort.int(alleles[[j]][,3],decreasing = TRUE,index.return = TRUE)$ix
	}
	print(sum(alleles[[j]][sortedindex,3])/sum(alleles[[j]][,3]))
	alleles2[[j]] = cbind(alleles[[j]][sortedindex,1],alleles[[j]][sortedindex,2])
}
alleles2
}


calculate_frequencies3 = function(genotypedata, alleles_definitions) {
	
ids = genotypedata$Sample.ID
locinames = unique(sapply(colnames(genotypedata)[-1],function(x) strsplit(x,"_")[[1]][1]))
nids = length(ids)
nloci = length(locinames)

frequencies = list()

variability = c()

for (j in 1:nloci) {
	locicolumns = grepl(paste(locinames[j],"_",sep=""),colnames(genotypedata))
	raw_alleles = c(as.matrix(genotypedata[,locicolumns]))
	raw_alleles = raw_alleles[!is.na(raw_alleles)]
	low = alleles_definitions[[j]][,1]
	high = alleles_definitions[[j]][,2]
	frequencies[[j]] = sapply(1:dim(alleles_definitions[[j]])[1],function (x) sum(raw_alleles > low[x] & raw_alleles <= high[x]))
	meanSD = mean(sapply(1:dim(alleles_definitions[[j]])[1],function (x) sd(raw_alleles[raw_alleles > low[x] & raw_alleles <= high[x]])),na.rm=TRUE)
	if(is.na(meanSD)) {meanSD = 0}
	variability[j] = meanSD
	frequencies[[j]] = frequencies[[j]] / length(raw_alleles)
}
freqmatrix = matrix(0,nloci,max(unlist(lapply(frequencies,length))))

for (j in 1:nloci) {
	freqmatrix[j,1:length(frequencies[[j]])] = frequencies[[j]]
}

ret = list()
ret[[1]] = unlist(lapply(frequencies,length))
ret[[2]] = freqmatrix
ret[[3]] = variability
ret
}


# Switch hidden - update hidden observations as part of Gibbs MCMC 

switch_hidden = function(x, hidden0, hiddenf, recoded0, recodedf, alleles0, allelesf,
    classification, mindistance, alldistance, allrecrf,
    recr0, recrf, recr_repeats0, recr_repeatsf,
    nloci, maxMOI, MOI0, MOIf, qq, dvect,
    alleles_definitions_RR, frequencies_RR, correction_distance_matrix) {
  
	z = runif(1)
	if (sum(hidden0[x,], hiddenf[x,],na.rm=TRUE) > 0) { # if hidden alleles exist
		if (length(which(c(hidden0[x,], hiddenf[x,])==1))>1) {
			chosen = sample(which(c(hidden0[x,], hiddenf[x,])==1),1)
		} else {
			chosen = which(c(hidden0[x,], hiddenf[x,])==1)
		}
	  
		if (classification[x] == 0) { # reinfection
			if (chosen <= nloci*maxMOI) { # day 0 hidden allele
				chosenlocus = ceiling(chosen/maxMOI)
				old = recoded0[x,chosen]
				new = sample(1:frequencies_RR[[1]][chosenlocus],1)


				oldalleles = recoded0[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hidden0[x,] == 0))]
				repeatedold = qq
				repeatednew = qq
				if (sum(oldalleles == old) >= 1) { # if old allele is a repeat, don't penalize with missing probability
					repeatedold = 1;
				}
				if (sum(oldalleles == new) >= 1) { # if new allele is a repeat, don't penalize with missing probability
					repeatednew = 1;
				}
				alpha = (sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,new]+1]) * repeatednew) / 
					   (sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,old]+1]) * repeatedold)
				if (z < alpha) { # switch made
					recoded0[x,chosen] = new
					newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,]) + rnorm(1,mean=0,sd=frequencies_RR[[3]][chosenlocus])

					alleles0[x,chosen] = newallele_length

						allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])
						closestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]])))
						mindistance[x,chosenlocus] = abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,2]])
						alldistance[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]]))
						allrecrf[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = recodedf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[,2]]
						recr0[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,1]
						recrf[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,2]
						recr_repeats0[x,chosenlocus] = sum(recoded0[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recoded0[x,recr0[x,chosenlocus]])
						recr_repeatsf[x,chosenlocus] = sum(recodedf[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recodedf[x,recrf[x,chosenlocus]])
					# }
				}
			} else { # day f hidden allele
				chosen = chosen - nloci*maxMOI
				chosenlocus = ceiling(chosen/maxMOI)
				old = recodedf[x,chosen]
				new = sample(1:frequencies_RR[[1]][chosenlocus],1)
				oldalleles = recodedf[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hiddenf[x,] == 0))]
				repeatedold = qq
				repeatednew = qq
				if (sum(oldalleles == old) >= 1) { # if old allele is a repeat, don't penalize with missing probability
					repeatedold = 1;
				}
				if (sum(oldalleles == new) >= 1) { # if new allele is a repeat, don't penalize with missing probability
					repeatednew = 1;
				}
				alpha = (sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,new]+1]) * repeatednew) / 
					   (sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,old]+1]) * repeatedold)
				if (z < alpha) { # switch made
					recodedf[x,chosen] = new
					newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,]) + rnorm(1,mean=0,sd=frequencies_RR[[3]][chosenlocus])

					####### new allele should have some variability (ie what's being see in real data)
					

					allelesf[x,chosen] = newallele_length
					# if (recrf[x,chosenlocus] == chosen) { # update mindistance
						allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])
						closestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]])))
						mindistance[x,chosenlocus] = abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,2]])
						alldistance[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = sapply(1:dim(allpossiblerecrud)[1], function (y) abs(alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]]))
						allrecrf[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = recodedf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[,2]]
						recr0[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,1]
						recrf[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[closestrecrud,2]
						recr_repeats0[x,chosenlocus] = sum(recoded0[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recoded0[x,recr0[x,chosenlocus]])
						recr_repeatsf[x,chosenlocus] = sum(recodedf[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recodedf[x,recrf[x,chosenlocus]])
					# }
				}
			}
		} else { # recrudescence
			if (chosen <= nloci*maxMOI) { # day 0 hidden allele
				chosenlocus = ceiling(chosen/maxMOI)
				old = recoded0[x,chosen]
				new = sample(1:frequencies_RR[[1]][chosenlocus],1)
#				newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,])
				newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,]) + rnorm(1,mean=0,sd=frequencies_RR[[3]][chosenlocus])

				
				oldalleles = recoded0[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hidden0[x,] == 0))]
				repeatedold = qq
				repeatednew = qq
				if (sum(oldalleles == old) >= 1) { # if old allele is a repeat, don't penalize with missing probability
					repeatedold = 1;
				}
				if (sum(oldalleles == new) >= 1) { # if new allele is a repeat, don't penalize with missing probability
					repeatednew = 1;
				}
				allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])
				tempalleles = alleles0[x,maxMOI*(chosenlocus-1)+1:maxMOI]
				tempalleles[chosen-(chosenlocus-1)*maxMOI] = newallele_length 
				temprecoded = recoded0[x,maxMOI*(chosenlocus-1)+1:maxMOI]
				temprecoded[chosen-(chosenlocus-1)*maxMOI] = new

				newclosestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(tempalleles[allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]])))
				newmindistance = abs(tempalleles[allpossiblerecrud[newclosestrecrud,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,2]])
				newalldistance = sapply(1:dim(allpossiblerecrud)[1], function (y) abs(tempalleles[allpossiblerecrud[y,1]] - allelesf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,2]]))
				newallrecrf = recodedf[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[,2]]

				# calculate new multiple-comparisons coefficient
				newrecr0 = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,1]
				newrecrf = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,2]
				newrecr_repeats0 = sum(temprecoded == temprecoded[allpossiblerecrud[newclosestrecrud,1]],na.rm=TRUE)
				newrecr_repeatsf = sum(recodedf[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recodedf[x,newrecrf])

				#likelihoodnew = mean(dvect[round(newalldistance)+1]/frequencies_RR[[2]][chosenlocus,newallrecrf],na.rm=TRUE) * repeatednew
				likelihoodnew = mean(dvect[round(newalldistance)+1]/sapply(1:length(newallrecrf), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,newallrecrf[z]]+1])),na.rm=TRUE) * repeatednew
				#likelihoodold = mean(dvect[round(alldistance[x,chosenlocus,])+1]/frequencies_RR[[2]][chosenlocus,allrecrf[x,chosenlocus,]],na.rm=TRUE) * repeatedold 
				likelihoodold = mean(dvect[round(alldistance[x,chosenlocus,])+1]/sapply(1:(maxMOI*maxMOI), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,allrecrf[x,chosenlocus,z]]+1])),na.rm=TRUE) * repeatedold 

				if (is.na(likelihoodnew) | is.na(likelihoodold)) { # debug
					write.csv(alleles0,"alleles0.csv")
					write.csv(allelesf,"allelesf.csv")
					write.csv(hidden0,"hidden0.csv")
					write.csv(hiddenf,"hiddenf.csv")
					write.csv(dvect,"dvect.csv")
					print(chosen)
					print(chosenlocus)
					print(chosenlocus)
					print(old)
					print(new)
					print(newallele_length)
					print(tempalleles)
					write.csv(newalldistance,"newalldistance.csv")
					write.csv(alldistance,"alldistance.csv")
				}

				if (likelihoodnew  == likelihoodold) {
					# if both num and denominator are equal (for case when both are 0..., otherwise 0/0 gives NaN)
					alpha = 1							 
				} else {
					alpha = likelihoodnew / likelihoodold 						 
				}

				if (z < alpha) { # switch made
					recoded0[x,chosen] = new
					alleles0[x,chosen] = newallele_length
					mindistance[x,chosenlocus] = newmindistance
					alldistance[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = newalldistance
					allrecrf[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = newallrecrf
					recr0[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,1]
					recrf[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,2]
					recr_repeats0[x,chosenlocus] = sum(recoded0[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recoded0[x,recr0[x,chosenlocus]])
					recr_repeatsf[x,chosenlocus] = sum(recodedf[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recodedf[x,recrf[x,chosenlocus]])
				}
			} else { # day f hidden allele
				chosen = chosen - nloci*maxMOI
				chosenlocus = ceiling(chosen/maxMOI)
				old = recodedf[x,chosen]
				new = sample(1:frequencies_RR[[1]][chosenlocus],1)
				#newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,])
				newallele_length = mean(alleles_definitions_RR[[chosenlocus]][new,]) + rnorm(1,mean=0,sd=frequencies_RR[[3]][chosenlocus])
				
				oldalleles = recodedf[x,intersect(((chosenlocus-1)*maxMOI+1):((chosenlocus)*maxMOI),which(hiddenf[x,] == 0))]
				repeatedold = qq
				repeatednew = qq
				if (sum(oldalleles == old) >= 1) { # if old allele is a repeat, don't penalize with missing probability
					repeatedold = 1;
				}
				if (sum(oldalleles == new) >= 1) { # if new allele is a repeat, don't penalize with missing probability
					repeatednew = 1;
				}
				allpossiblerecrud = expand.grid(1:MOI0[x],1:MOIf[x])
				tempalleles = allelesf[x,maxMOI*(chosenlocus-1)+1:maxMOI]
				tempalleles[chosen-(chosenlocus-1)*maxMOI] = newallele_length 
				temprecoded = recodedf[x,maxMOI*(chosenlocus-1)+1:maxMOI]
				temprecoded[chosen-(chosenlocus-1)*maxMOI] = new
				newclosestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (y) abs(tempalleles[allpossiblerecrud[y,2]] - alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]])))
				newmindistance = abs(tempalleles[allpossiblerecrud[newclosestrecrud,2]] - alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,1]])
				newalldistance = sapply(1:dim(allpossiblerecrud)[1], function (y) abs(tempalleles[allpossiblerecrud[y,2]] - alleles0[x,maxMOI*(chosenlocus-1)+allpossiblerecrud[y,1]]))
				newallrecrf = temprecoded[allpossiblerecrud[,2]]

				# calculate new multiple-comparisons coefficient
				newrecr0 = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,1]
				newrecrf = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,2]
				newrecr_repeats0 = sum(recoded0[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recoded0[x,newrecr0])
				newrecr_repeatsf = sum(temprecoded == temprecoded[allpossiblerecrud[newclosestrecrud,2]],na.rm=TRUE)

				likelihoodnew = mean(dvect[round(newalldistance)+1]/sapply(1:length(newallrecrf), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,newallrecrf[z]]+1])),na.rm=TRUE) * repeatednew
				 
				likelihoodold = mean(dvect[round(alldistance[x,chosenlocus,])+1]/sapply(1:(maxMOI*maxMOI), function (z) sum(frequencies_RR[[2]][chosenlocus,1:frequencies_RR[[1]][chosenlocus]]*dvect[correction_distance_matrix[[chosenlocus]][,allrecrf[x,chosenlocus,z]]+1])),na.rm=TRUE) * repeatedold 

				if (is.na(likelihoodnew) | is.na(likelihoodold)) { # debug
					write.csv(alleles0,"alleles0.csv")
					write.csv(allelesf,"allelesf.csv")
					write.csv(hidden0,"hidden0.csv")
					write.csv(hiddenf,"hiddenf.csv")
					write.csv(dvect,"dvect.csv")
					print(chosen)
					print(chosenlocus)
					print(chosenlocus)
					print(old)
					print(new)
					print(newallele_length)
					print(tempalleles)
					write.csv(newalldistance,"newalldistance.csv")
					write.csv(alldistance,"alldistance.csv")
				}


				if (likelihoodnew  == likelihoodold) {
					# if both num and denominator are equal (for case when both are 0..., otherwise 0/0 gives NaN)
					alpha = 1							 
				} else {
					alpha = likelihoodnew / likelihoodold 						 
				}
				if (z < alpha) { # switch made
					recodedf[x,chosen] = new
					allelesf[x,chosen] = newallele_length
					mindistance[x,chosenlocus] = newmindistance
					alldistance[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = newalldistance
					allrecrf[x,chosenlocus,1:dim(allpossiblerecrud)[1]] = newallrecrf
					recr0[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,1]
					recrf[x,chosenlocus] = maxMOI*(chosenlocus-1)+allpossiblerecrud[newclosestrecrud,2]
					recr_repeats0[x,chosenlocus] = sum(recoded0[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recoded0[x,recr0[x,chosenlocus]])
					recr_repeatsf[x,chosenlocus] = sum(recodedf[x,(maxMOI*(chosenlocus-1)+1) : (maxMOI*(chosenlocus))] == recodedf[x,recrf[x,chosenlocus]])
				}
			}
		}
	}
	return(list(
        hidden0=hidden0, hiddenf=hiddenf, recoded0=recoded0, recodedf=recodedf, 
        alleles0=alleles0, allelesf=allelesf, mindistance=mindistance, alldistance=alldistance, 
        allrecrf=allrecrf, recr0=recr0, recrf=recrf, 
        recr_repeats0=recr_repeats0, recr_repeatsf=recr_repeatsf
    ))
}
```



# MCMC Algorithm

## Parallel processing

```{r}

# call sourece for MCMC Diagnosis
source("mcmc_report_generator.R")

# Define the chain function for parallel processing
run_one_chain <- function(chain_id,
                          nruns, burnin, record_interval,
                          nids, nloci, maxMOI, locinames,
                          genotypedata_RR, additional_neutral, alleles_definitions_RR
                          ) {
  
  message(sprintf("  PID %d: Starting Chain %d...", Sys.getpid(), chain_id))
  
  loglikelihood_chain <- rep(NA_real_, nruns)  # Track unset values
  attr(loglikelihood_chain, "bounds") <- c(-1e100, 1e100)  
  
  ##### calculate MOI
  MOI0 <- rep(0, nids)
  MOIf <- rep(0, nids)
  for (i in 1:nids) {
    for (j in 1:nloci) {
      locicolumns <- grepl(paste(locinames[j], "_", sep = ""), colnames(genotypedata_RR))
      nalleles0 <- sum(!is.na(genotypedata_RR[grepl(paste(ids[i], "Day 0"), genotypedata_RR$Sample.ID), locicolumns]))
      nallelesf <- sum(!is.na(genotypedata_RR[grepl(paste(ids[i], "Day Failure"), genotypedata_RR$Sample.ID), locicolumns]))
      MOI0[i] <- max(MOI0[i], nalleles0)
      MOIf[i] <- max(MOIf[i], nallelesf)
    }
  }
  
  ##### define state vector and create state 0
  
  alleles0 <- matrix(0, nids, maxMOI * nloci)
  recoded0 <- matrix(0, nids, maxMOI * nloci)
  hidden0 <- matrix(NA, nids, maxMOI * nloci)
  recr0 <- matrix(NA, nids, nloci)
  recr_repeats0 <- matrix(NA, nids, nloci)
  allelesf <- matrix(0, nids, maxMOI * nloci)
  recodedf <- matrix(0, nids, maxMOI * nloci)
  hiddenf <- matrix(NA, nids, maxMOI * nloci)
  recrf <- matrix(NA, nids, nloci)
  recr_repeatsf <- matrix(NA, nids, nloci) 
  if (length(additional_neutral) > 0 && nrow(additional_neutral) > 0) {
    recoded_additional_neutral <- matrix(0, nrow(additional_neutral), maxMOI * nloci)
  }
  mindistance <- matrix(0, nids, nloci)
  alldistance <- array(NA, c(nids, nloci, maxMOI * maxMOI))
  allrecrf <- array(NA, c(nids, nloci, maxMOI * maxMOI))
  classification <- rep(0, nids)
  

  for (j in 1:nloci) {
      locus = locinames[j]
      locicolumns = grepl(paste0(locus, "_"), colnames(genotypedata_RR))
      oldalleles = as.matrix(genotypedata_RR[, locicolumns])
      if (is.null(dim(oldalleles))) { oldalleles = matrix(oldalleles, ncol=1) }
      ncolumns = ncol(oldalleles)
      newalleles = matrix(NA, nrow = nrow(oldalleles), ncol = ncolumns)
      for (i in 1:ncolumns) { newalleles[, i] = sapply(1:nrow(oldalleles), function(x) recodeallele(alleles_definitions_RR[[j]],
                                                                                                    oldalleles[x, i])) }
      newalleles = matrix(as.numeric(newalleles), nrow = nrow(oldalleles), ncol = ncolumns)
      newalleles[is.na(newalleles)] = 0
      oldalleles = matrix(as.numeric(oldalleles), nrow = nrow(oldalleles), ncol = ncolumns)
      oldalleles[is.na(oldalleles)] = 0
      oldalleles[newalleles == 0] = 0
      day0_rows = grepl("Day 0", genotypedata_RR$Sample.ID)
      dayf_rows = grepl("Day Failure", genotypedata_RR$Sample.ID)
      alleles0[, (maxMOI*(j-1)+1):(maxMOI*(j-1)+ncolumns)] = oldalleles[day0_rows, , drop=FALSE]
      allelesf[, (maxMOI*(j-1)+1):(maxMOI*(j-1)+ncolumns)] = oldalleles[dayf_rows, , drop=FALSE]
      recoded0[, (maxMOI*(j-1)+1):(maxMOI*(j-1)+ncolumns)] = newalleles[day0_rows, , drop=FALSE]
      recodedf[, (maxMOI*(j-1)+1):(maxMOI*(j-1)+ncolumns)] = newalleles[dayf_rows, , drop=FALSE]
  }
  if (length(additional_neutral) > 0 && nrow(additional_neutral) > 0) {
      recoded_additional_neutral = matrix(0, nrow = nrow(additional_neutral), ncol = maxMOI * nloci)
      for (j in 1:nloci) {
          locus = locinames[j]
          locicolumns = grepl(paste0(locus, "_"), colnames(additional_neutral))
          oldalleles = as.matrix(additional_neutral[, locicolumns])
          if (is.null(dim(oldalleles))) { oldalleles = matrix(oldalleles, ncol = 1) }
          ncolumns = ncol(oldalleles)
          newalleles = matrix(NA, nrow = nrow(oldalleles), ncol = ncolumns)
          for (i in 1:ncolumns) { newalleles[, i] = sapply(1:nrow(oldalleles), function(x) recodeallele(alleles_definitions_RR[[j]],
                                                                                                        oldalleles[x, i])) }
          newalleles = matrix(as.numeric(newalleles), nrow = nrow(oldalleles), ncol = ncolumns)
          newalleles[is.na(newalleles)] = 0
          oldalleles = matrix(as.numeric(oldalleles), nrow = nrow(oldalleles), ncol = ncolumns)
          oldalleles[is.na(oldalleles)] = 0
          oldalleles[newalleles == 0] = 0
          recoded_additional_neutral[, (maxMOI*(j-1)+1):(maxMOI*(j-1)+ncolumns)] = newalleles
      }
  } else { recoded_additional_neutral = c() }
  

  frequencies_RR <- calculate_frequencies3(rbind(genotypedata_RR, additional_neutral), alleles_definitions_RR)
  
  ## assign random hidden alleles and classifications
  for (i in 1:nids) {
      for (j in 1:nloci) {
          nalleles0 = sum(alleles0[i,(maxMOI*(j-1)+1) : (maxMOI*(j))] != 0); nmissing0 = MOI0[i] - nalleles0; whichnotmissing0 =
            ((maxMOI*(j-1)+1) : (maxMOI*(j)))[which(alleles0[i,(maxMOI*(j-1)+1) : (maxMOI*(j-1)+MOI0[i])] != 0)]; whichmissing0 =
              ((maxMOI*(j-1)+1) : (maxMOI*(j)))[which(alleles0[i,(maxMOI*(j-1)+1) : (maxMOI*(j-1)+MOI0[i])] == 0)];
            if (nalleles0 > 0) { hidden0[i,whichnotmissing0] = 0 }
            if (nmissing0 > 0) { newhiddenalleles0 =
              sample(1:(frequencies_RR[[1]][j]),nmissing0,replace=TRUE,frequencies_RR[[2]][j,1:(frequencies_RR[[1]][j])]);
            recoded0[i,whichmissing0] = newhiddenalleles0; alleles0[i,whichmissing0] =
              rowMeans(alleles_definitions_RR[[j]])[newhiddenalleles0]; hidden0[i,whichmissing0] = 1; }
            nallelesf = sum(allelesf[i,(maxMOI*(j-1)+1) : (maxMOI*(j))] != 0); nmissingf = MOIf[i] - nallelesf; whichnotmissingf =
              ((maxMOI*(j-1)+1) : (maxMOI*(j)))[which(allelesf[i,(maxMOI*(j-1)+1) : (maxMOI*(j-1)+MOIf[i])] != 0)]; whichmissingf =
              ((maxMOI*(j-1)+1) : (maxMOI*(j)))[which(allelesf[i,(maxMOI*(j-1)+1) : (maxMOI*(j-1)+MOIf[i])] == 0)];
            if (nallelesf > 0) { hiddenf[i,whichnotmissingf] = 0 }
            if (nmissingf > 0) { newhiddenallelesf =
              sample(1:(frequencies_RR[[1]][j]),nmissingf,replace=TRUE,frequencies_RR[[2]][j,1:(frequencies_RR[[1]][j])]);
            recodedf[i,whichmissingf] = newhiddenallelesf; allelesf[i,whichmissingf] =
              rowMeans(alleles_definitions_RR[[j]])[newhiddenallelesf]; hiddenf[i,whichmissingf] = 1; }
      }
  }
  
  
  qq <- mean(c(hidden0, hiddenf), na.rm = TRUE)
  dvect <- dgeom(0:(round(max(sapply(1:nloci, function(x) diff(range(c(alleles_definitions_RR[[x]]))))))), 0.75)
  
  ## randomly assign recrudescences/reinfections for this chain
  
  classification <- ifelse(runif(nids) < 0.5, 1, 0)
  for (i in 1:nids) {
    for (j in 1:nloci) {
      allpossiblerecrud = expand.grid(1:MOI0[i],1:MOIf[i]); closestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (x)
        abs(alleles0[i,maxMOI*(j-1)+allpossiblerecrud[x,1]] - allelesf[i,maxMOI*(j-1)+allpossiblerecrud[x,2]]))); mindistance[i,j] =
          abs(alleles0[i,maxMOI*(j-1)+allpossiblerecrud[closestrecrud,1]] - allelesf[i,maxMOI*(j-1)+allpossiblerecrud[closestrecrud,2]]);
        alldistance[i,j,1:dim(allpossiblerecrud)[1]] = sapply(1:dim(allpossiblerecrud)[1], function (x)
          abs(alleles0[i,maxMOI*(j-1)+allpossiblerecrud[x,1]] - allelesf[i,maxMOI*(j-1)+allpossiblerecrud[x,2]]));
        allrecrf[i,j,1:dim(allpossiblerecrud)[1]] = recodedf[i,maxMOI*(j-1)+allpossiblerecrud[,2]]; recr0[i,j] =
          maxMOI*(j-1)+allpossiblerecrud[closestrecrud,1]; recrf[i,j] = maxMOI*(j-1)+allpossiblerecrud[closestrecrud,2];
          recr_repeats0[i,j] = sum(recoded0[i,(maxMOI*(j-1)+1) : (maxMOI*(j))] == recoded0[i,recr0[i,j]])
          recr_repeatsf[i,j] = sum(recodedf[i,(maxMOI*(j-1)+1) : (maxMOI*(j))] == recodedf[i,recrf[i,j]])
          }
  }
  
  correction_distance_matrix <- list()
  for (i in 1:nloci) { correction_distance_matrix[[i]] <- as.matrix(dist(rowMeans(alleles_definitions_RR[[i]]))) }
  
  
  
  
  state_classification <- matrix(NA, nids, (nruns - burnin) / record_interval)
  state_parameters <- matrix(NA, 2 + 2 * nloci, (nruns - burnin) / record_interval)
  state_alleles0 <- array(NA, c(nids, maxMOI * nloci, (nruns - burnin) / record_interval))
  state_allelesf <- array(NA, c(nids, maxMOI * nloci, (nruns - burnin) / record_interval))
  state_loglikelihood <- rep(NA_real_, (nruns - burnin) / record_interval)


  # Define ALL variables needed by runmcmc() before it's defined.
  count <- 1
  dposterior <- 0.75

  
  # Define MCMC function

  runmcmc <- function() {
    calculate_single_locus <- function(x, y) {
  should_print_debug <- (count < 5)
  distances <- round(alldistance[x, y, ])
  valid <- !is.na(distances) & distances >= 0 & distances < length(dvect)
  if (!any(valid)) {
    if (should_print_debug) {
      message(sprintf("\n--- DEBUG (Count %d, Indiv %d, Locus %d): EARLY EXIT ---", count, x, y))
      message("Reason: No valid distances found. All calculations for this locus will be skipped.")
      message(sprintf("Length of dvect: %d", length(dvect)))
      message("Distances found (includes NAs and out-of-bounds values):")
      print(head(distances, 20)) 
    }
    return(1)
  }
  numerator <- dvect[distances[valid] + 1]

  denominators <- sapply(which(valid), function(z) {
    recr_allele <- allrecrf[x, y, z]
    if (is.na(recr_allele)) {
      return(NA) 
    }
    sum(
      frequencies_RR[[2]][y, 1:frequencies_RR[[1]][y]] *
      dvect[correction_distance_matrix[[y]][, recr_allele] + 1]
    )
  })
  
  epsilon <- 1e-10
  ratios <- numerator / (denominators + epsilon)
  
  final_ratios <- ratios[!is.na(ratios) & is.finite(ratios)]
  
  if (length(final_ratios) == 0) {
    if (should_print_debug) {
      message(sprintf("\n--- DEBUG (Count %d, Indiv %d, Locus %d): LATE EXIT ---", count, x, y))
      message("Reason: All calculated ratios were invalid (NA/Inf) and were filtered out.")
      message("Numerator(s) calculated:")
      print(head(numerator, 20))
      message("Denominator(s) calculated (before adding epsilon):")
      print(head(denominators, 20)) 
    }
    return(1) 
  }
  
  return(mean(final_ratios))
}
  
  likelihoodratio <- sapply(1:nids, function(x) {
    loc_results <- sapply(1:nloci, function(y) calculate_single_locus(x, y))
    exp(sum(log(pmax(loc_results, 1e-10))))
  })
    z = runif(nids); newclassification = classification; newclassification[classification == 0 & z < likelihoodratio] = 1; newclassification[classification == 1 & z < 1/likelihoodratio] = 0; classification <<- newclassification
  
    loglik_val <- sum(log(pmax(pmin(likelihoodratio, 1e100), 1e-100)))  # Clamp values
    loglikelihood_chain[count] <<- ifelse(is.finite(loglik_val), loglik_val, NA)
        
    for (i in 1:nids) {
      updated_states <- switch_hidden(
      x = i,
      hidden0 = hidden0, hiddenf = hiddenf, recoded0 = recoded0, recodedf = recodedf, 
      alleles0 = alleles0, allelesf = allelesf, classification = classification,
      mindistance = mindistance, alldistance = alldistance, allrecrf = allrecrf,
      recr0 = recr0, recrf = recrf, recr_repeats0 = recr_repeats0, recr_repeatsf = recr_repeatsf,
      nloci = nloci, maxMOI = maxMOI, MOI0 = MOI0, MOIf = MOIf, qq = qq, dvect = dvect,
      alleles_definitions_RR = alleles_definitions_RR, frequencies_RR = frequencies_RR,
      correction_distance_matrix = correction_distance_matrix
    )
    
    hidden0       <<- updated_states$hidden0
    hiddenf       <<- updated_states$hiddenf
    recoded0      <<- updated_states$recoded0
    recodedf      <<- updated_states$recodedf
    alleles0      <<- updated_states$alleles0
    allelesf      <<- updated_states$allelesf
    mindistance   <<- updated_states$mindistance
    alldistance   <<- updated_states$alldistance
    allrecrf      <<- updated_states$allrecrf
    recr0         <<- updated_states$recr0
    recrf         <<- updated_states$recrf
    recr_repeats0 <<- updated_states$recr_repeats0
    recr_repeatsf <<- updated_states$recr_repeatsf
  }
        
  q_prior_alpha = 0; 
  q_prior_beta = 0; 
  q_posterior_alpha = q_prior_alpha + sum(c(hidden0,hiddenf) == 1,na.rm=TRUE); 
  q_posterior_beta = q_prior_beta + sum(c(hidden0,hiddenf)==0,na.rm=TRUE); 
  if (q_posterior_alpha == 0) { q_posterior_alpha =1 }; 
  qq <<- rbeta(1, q_posterior_alpha , q_posterior_beta)
  
  if (sum(classification==1) >= 1) {
      d_prior_alpha = 0; d_prior_beta = 0; 
      d_posterior_alpha = d_prior_alpha + length(c(mindistance[classification==1,])); 
      d_posterior_beta = d_prior_beta + sum(c(round(mindistance[classification==1,])));
      if (d_posterior_beta == 0) { d_posterior_beta = sum(c((mindistance[classification==1,]))) }
      if (d_posterior_beta == 0) { d_posterior_beta = 1 }
      dposterior <<- rbeta(1, d_posterior_alpha , d_posterior_beta); 
      dvect = (1-dposterior) ^ (1:length(dvect)-1) * dposterior; 
      dvect <<- dvect / (sum(dvect))
  }
        
  
  tempdata <- recoded0
  recrudescence_indices <- which(classification == 1)
  if (length(recrudescence_indices) > 0) {
    for (idx in recrudescence_indices) { tempdata[idx, recr0[idx,]] <- 0 }
  }
  tempdata <- rbind(tempdata, recodedf)
  full_data <- rbind(tempdata, recoded_additional_neutral)
  
  for (locus_idx in 1:nloci) {
    updated_frequencies <- findposteriorfrequencies(
      locus_index = locus_idx,
      tempdata = full_data,
      maxMOI = maxMOI,
      frequencies_RR = frequencies_RR
    )
    frequencies_RR <<- updated_frequencies
  }

     
  if (count > burnin & count %% record_interval == 0) {
      record_idx <- (count - burnin) / record_interval
      state_classification[, record_idx] <<- classification
      state_alleles0[,, record_idx] <<- alleles0
      state_allelesf[,, record_idx] <<- allelesf
      state_parameters[1, record_idx] <<- qq
      state_parameters[2, record_idx] <<- dposterior
      state_parameters[3:(3+nloci-1), record_idx] <<- apply(frequencies_RR[[2]],1,max)
      state_parameters[(3+nloci):(3+2*nloci-1), record_idx] <<- sapply(1:nloci,function (x) sum(frequencies_RR[[2]][x,]^2))
      state_loglikelihood[record_idx] <<- loglikelihood_chain[count]
  }
        
        
        
  for (locus_idx in 1:nloci) {
    updated_frequencies <- findposteriorfrequencies(
    locus_index = locus_idx,
    tempdata = full_data,
    maxMOI = maxMOI,
    frequencies_RR = frequencies_RR
  )


  frequencies_RR <<- updated_frequencies
        }
  count <<- count + 1
}
    
  # Execute the MCMC for the current chain - This remains unchanged
  replicate(nruns, runmcmc())
  
  
  return(
    list(
      classification = state_classification[, !is.na(colSums(state_classification)), drop = FALSE],
      parameters     = state_parameters[, !is.na(colSums(state_parameters)), drop = FALSE],
      alleles0       = state_alleles0[,, !is.na(colSums(state_parameters)), drop = FALSE],
      allelesf       = state_allelesf[,, !is.na(colSums(state_parameters)), drop = FALSE],
      loglikelihood  = state_loglikelihood
    )
  )
  
}  
  

# Define Core MCMC and Data Parameters
site_names <- unique(genotypedata_latefailures$Site)

# Global Storage for Aggregating Results ACROSS ALL SITES 
all_sites_classification <- list()
all_sites_parameters <- list()
all_sites_alleles0 <- list() 
all_sites_allelesf <- list() 
all_sites_ids <- list()

# Configure Parallel Plan (Once, for efficiency)
plan(multisession, workers = n_chains)


# Loop per site analysis

for (site in site_names) {
    jobname <- site
    
    # Site-Specific Data Preparation
    genotypedata_RR <- genotypedata_latefailures[genotypedata_latefailures$Site == site, -c(2)]
    additional_neutral <- additional_genotypedata[additional_genotypedata$Site == site, -c(2)]
    maxMOI = max(as.numeric(sapply(1:length(colnames(genotypedata_RR)), function (x)
        strsplit(colnames(genotypedata_RR)[x],"_")[[1]][2])),na.rm=TRUE)
    ids = unique(unlist(strsplit(genotypedata_RR$Sample.ID[grepl("Day 0",genotypedata_RR$Sample.ID)]," Day 0")))
    locinames = unique(sapply(colnames(genotypedata_RR)[-1],function(x) strsplit(x,"_")[[1]][1]))
    nloci = length(locinames)
    nids = length(ids)
    maxalleles=30
    k = rep(maxalleles, nloci)
    alleles_definitions_RR  = define_alleles(rbind(genotypedata_RR,additional_neutral),locirepeats,k)
    
    # Automated MCMC Loop
    full_loglik_history <- list()
    full_chain_results <- list()  
    total_iterations <- 0
    converged <- FALSE
    
    while (!converged && total_iterations < max_iterations) {
        total_iterations <- total_iterations + chunk_size
        cat(sprintf("Running chunk: Iterations %d to %d...\n", total_iterations - chunk_size + 1, total_iterations))
        
        chunk_results <- future_lapply(1:n_chains, function(id) {
            run_one_chain(
                chain_id = id, nruns = chunk_size, burnin = 0, record_interval = 10,
                nids = nids, nloci = nloci, maxMOI = maxMOI, locinames = locinames,
                genotypedata_RR = genotypedata_RR, 
                additional_neutral = additional_neutral, 
                alleles_definitions_RR = alleles_definitions_RR
            )
        }, future.seed = TRUE)
        
        # Append results to the full history
        if (length(full_chain_results) == 0) {
            full_chain_results <- chunk_results
            full_loglik_history <- lapply(chunk_results, `[[`, "loglikelihood")
        } else {
            for (i in 1:n_chains) {
                full_chain_results[[i]]$parameters <- cbind(full_chain_results[[i]]$parameters, chunk_results[[i]]$parameters)
                full_chain_results[[i]]$classification <- cbind(full_chain_results[[i]]$classification, chunk_results[[i]]$classification)
                full_chain_results[[i]]$alleles0 <- abind(full_chain_results[[i]]$alleles0, chunk_results[[i]]$alleles0, along = 3)
                full_chain_results[[i]]$allelesf <- abind(full_chain_results[[i]]$allelesf, chunk_results[[i]]$allelesf, along = 3)
                full_loglik_history[[i]] <- c(full_loglik_history[[i]], chunk_results[[i]]$loglikelihood)
            }
        }
        
        # Robust Convergence Check
        if (length(full_loglik_history) == 0 || length(full_loglik_history[[1]]) == 0) {
            cat("Log-likelihood history is not populated yet. Running another chunk...\n")
            next
        }
        
        mcmc_list_loglik <- coda::mcmc.list(lapply(full_loglik_history, coda::mcmc))
        n_samples <- nrow(mcmc_list_loglik[[1]])
        burn_in_end <- floor(burn_in_frac * n_samples)
        
        if (is.null(n_samples) || (n_samples - burn_in_end < 50)) { next }
        
        post_burn_mcmc <- window(mcmc_list_loglik, start = burn_in_end + 1)
        r_hat <- try(coda::gelman.diag(post_burn_mcmc)$psrf[1, 1], silent = TRUE)
        ess <- try(coda::effectiveSize(post_burn_mcmc)[1], silent = TRUE)
        
        if (inherits(r_hat, "try-error") || inherits(ess, "try-error")) { next }
        r_hat_ok <- !is.na(r_hat) && r_hat < R_hat_threshold
        ess_ok <- !is.na(ess) && ess > ESS_threshold
        
        cat(sprintf("--- Convergence Check (Log-Likelihood Only) ---\n"))
        cat(sprintf("  R-hat: %.4f (Threshold: < %.2f) -> %s\n", r_hat, R_hat_threshold, ifelse(r_hat_ok, "OK", "FAIL")))
        cat(sprintf("  ESS:   %.1f (Threshold: > %d) -> %s\n", ess, ESS_threshold, ifelse(ess_ok, "OK", "FAIL")))
        
        if (r_hat_ok && ess_ok) {
            converged <- TRUE
            cat(sprintf("\nSUCCESS: Model for site '%s' CONVERGED after %d total iterations.\n", site, total_iterations))
        } else if (total_iterations >= max_iterations) {
            cat(sprintf("\nWARNING: Model for site '%s' FAILED TO CONVERGE after reaching max iterations.\n", site, max_iterations))
        }
    }

    # Post-processing and Saving Results for the CURRENT SITE
    num_total_samples_per_chain <- ifelse(length(full_chain_results) > 0, ncol(full_chain_results[[1]]$parameters), 0)
    if (num_total_samples_per_chain == 0) {
        next
    }
    
    burn_in_samples_per_chain <- floor(burn_in_frac * num_total_samples_per_chain)
    if (burn_in_samples_per_chain >= num_total_samples_per_chain) {
        cat(sprintf("WARNING: Burn-in resulted in 0 samples for site '%s'. Skipping analysis.\n", site))
        next
    }
    
    keep_indices <- (burn_in_samples_per_chain + 1):num_total_samples_per_chain

    final_classification <- do.call(cbind, lapply(full_chain_results, function(x) x$classification[, keep_indices, drop=FALSE]))
    final_parameters <- do.call(cbind, lapply(full_chain_results, function(x) x$parameters[, keep_indices, drop=FALSE]))
    final_loglikelihood <- lapply(full_loglik_history, function(x) x[keep_indices])
    final_alleles0 <- do.call(abind::abind, c(lapply(full_chain_results, function(x) x$alleles0[,, keep_indices, drop=FALSE]), along = 3))
    final_allelesf <- do.call(abind::abind, c(lapply(full_chain_results, function(x) x$allelesf[,, keep_indices, drop=FALSE]), along = 3))

    generate_likelihood_diagnostics(all_chains_loglikelihood = final_loglikelihood, site_name = site)
    
    modealleles <- matrix("", 2 * nids, maxMOI * nloci)
    for (i in 1:nids) {
        for (j in 1:nloci) {
            for (x in 1:maxMOI) {
                idx <- (j - 1) * maxMOI + x
                tbl0 <- table(final_alleles0[i, idx, ])
                if (length(tbl0) > 0) modealleles[2 * (i - 1) + 1, idx] <- names(tbl0)[which.max(tbl0)]
                tblf <- table(final_allelesf[i, idx, ])
                if (length(tblf) > 0) modealleles[2 * (i - 1) + 2, idx] <- names(tblf)[which.max(tblf)]
            }
        }
    }

    rowMeans2 <- function(x) { if (is.null(dim(x))) mean(x) else rowMeans(x) }

    prob_rec_combined <- rowMeans2(final_classification)
    temp_combined <- rep(prob_rec_combined, each = 2)
    
    outputmatrix <- cbind(temp_combined, modealleles)
    colnames(outputmatrix) <- c("Prob Rec", sapply(1:nloci, function(x) paste(locinames[x], "_", 1:maxMOI, sep = "")))
    write.csv(outputmatrix, paste(jobname, "_posterior", ".csv", sep = ""))
    write.csv(final_parameters, paste(jobname, "_state_parameters.csv", sep = ""))
    summary_statisticsmatrix <- cbind(
        format(rowMeans(final_parameters), digits = 2),
        apply(format(t(sapply(1:nrow(final_parameters), function(x) quantile(final_parameters[x, ], c(0.25, 0.75)))), digits = 2), 1, function(x) paste(x, collapse = "â€“"))
    )
    mean_diversity_samples <- colMeans(final_parameters[(3 + nloci):(3 + 2 * nloci - 1), ])
    summary_statisticsmatrix <- rbind(
        summary_statisticsmatrix,
        c(format(mean(mean_diversity_samples), digits = 2), paste(format(quantile(mean_diversity_samples, c(0.25, 0.75)), digits = 2), collapse = "â€“"))
    )
    summary_statisticsmatrix <- as.matrix(sapply(1:nrow(summary_statisticsmatrix), function(x) paste(summary_statisticsmatrix[x, 1], " (", summary_statisticsmatrix[x, 2], ")", sep = "")))
    rownames(summary_statisticsmatrix) <- c("q", "d", locinames, locinames, "Mean diversity")
    write.csv(summary_statisticsmatrix, paste(jobname, "_summarystatistics.csv", sep = ""))

    all_sites_classification[[site]] <- final_classification
    all_sites_parameters[[site]] <- final_parameters
    all_sites_alleles0[[site]] <- final_alleles0
    all_sites_allelesf[[site]] <- final_allelesf
    all_sites_ids[[site]] <- ids

} 
plan(sequential)

```


# Global Summary

```{r}

if (length(all_sites_ids) == 0) {
    stop("ERROR: No results were generated from any site. Cannot perform final analysis.")
}
list_of_site_dataframes <- lapply(names(all_sites_ids), function(site) {
    site_ids <- all_sites_ids[[site]]
    site_classification <- all_sites_classification[[site]]
    if (is.null(site_ids) || is.null(site_classification) || length(site_ids) != nrow(site_classification)) {
        warning(sprintf("Data for site '%s' is inconsistent or missing. It will be excluded from the final summary.", site))
        return(NULL)
    }
    data.frame(
        Site = site,
        ID = site_ids,
        Probability = rowMeans(site_classification),
        stringsAsFactors = FALSE
    )
})
clean_list_of_dataframes <- Filter(Negate(is.null), list_of_site_dataframes)
if (length(clean_list_of_dataframes) == 0) {
    stop("ERROR: All sites failed processing. No data available for final analysis.")
}
final_summary_df <- do.call(rbind, clean_list_of_dataframes)
hist(final_summary_df$Probability, breaks = 20, 
     main = "Distribution of posterior probability of recrudescence (Successful Sites)", 
     xlab = "Posterior probability of recrudescence")
write.csv(final_summary_df, "probability_of_recrudescence_summary.csv", row.names = FALSE)
genotypedata_latefailures$base_ID <- gsub(" Day 0| Day Failure", "", genotypedata_latefailures$Sample.ID)
matched_indices <- match(genotypedata_latefailures$base_ID, final_summary_df$ID)
probability_of_recrudescence_correctorder <- final_summary_df$Probability[matched_indices]
is_day_failure_row <- grepl("Day Failure", genotypedata_latefailures$Sample.ID)
probability_of_recrudescence_correctorder[is_day_failure_row] <- NA
probability_of_recrudescence_correctorder_formatted <- sapply(probability_of_recrudescence_correctorder, function(x) {
    if (is.na(x)) return("") else return(format(round(x, 2), nsmall = 2))
})
probability_of_recrudescence_correctorder2 <- probability_of_recrudescence_correctorder
probability_of_recrudescence_correctorder2[is.na(probability_of_recrudescence_correctorder2)] <- -1
```


### Match-counting Analysis

```{r, include = FALSE}
##### read in data

genotypedata_latefailures = as.data.frame(read_excel(inputfile, sheet = "Late Treatment Failures",skip=3))

# missing data has to be coded as NA
genotypedata_latefailures[genotypedata_latefailures == 0] = NA 
genotypedata_latefailures[genotypedata_latefailures == "0"] = NA 
genotypedata_latefailures[genotypedata_latefailures == "N/A"] = NA
genotypedata_latefailures[genotypedata_latefailures == "-"] = NA
genotypedata_latefailures[genotypedata_latefailures == "NA"] = NA

### recode sample names so that each pair has a " Day 0" and a " Day Failure"
genotypedata_latefailures$Sample.ID = sub("D0$"," Day 0",genotypedata_latefailures$Sample.ID)
genotypedata_latefailures$Sample.ID = sub("D[0-9]+$"," Day Failure",genotypedata_latefailures$Sample.ID)

genotypedata_latefailures = genotypedata_latefailures[,grepl("Sample", colnames(genotypedata_latefailures)) | grepl("_", colnames(genotypedata_latefailures))]

# each sample in genotypedata_latefailures has to have day 0 and day of Failure
ids = unique(unlist(strsplit(genotypedata_latefailures$Sample.ID[grepl("Day 0",genotypedata_latefailures$Sample.ID)]," Day 0")))
if (sum(!paste(ids, "Day Failure") %in% genotypedata_latefailures$Sample.ID) > 0) {
  print("Error - each sample must have day 0 and day of failure data")
}
ids = unique(unlist(strsplit(genotypedata_latefailures$Sample.ID[grepl("Day Failure",genotypedata_latefailures$Sample.ID)]," Day Failure")))
if (sum(!paste(ids, "Day 0") %in% genotypedata_latefailures$Sample.ID) > 0) {
  print("Error - each sample must have day 0 and day of failure data")
}


ids = unique(unlist(strsplit(genotypedata_latefailures$Sample.ID[grepl("Day 0",genotypedata_latefailures$Sample.ID)]," Day 0")))
locinames = unique(sapply(colnames(genotypedata_latefailures)[-1],function(x) strsplit(x,"_")[[1]][1]))
nloci = length(locinames)
nids = length(ids)


##### calculate MOI for each sample
MOI0 = rep(0,nids)
MOIf = rep(0,nids)
for (i in 1:nids) {
  for (j in 1:nloci) {
    locicolumns = grepl(paste(locinames[j],"_",sep=""),colnames(genotypedata_latefailures))
    nalleles0 = sum(!is.na(genotypedata_latefailures[grepl(paste(ids[i],"Day 0"),genotypedata_latefailures$Sample.ID),locicolumns]))
    nallelesf = sum(!is.na(genotypedata_latefailures[grepl(paste(ids[i],"Day Failure"),genotypedata_latefailures$Sample.ID),locicolumns]))
    
    MOI0[i] = max(MOI0[i],nalleles0)
    MOIf[i] = max(MOIf[i],nallelesf)
  }
}
maxMOI = max(c(MOI0, MOIf),na.rm=TRUE)


alleles0 = matrix(NA,nids,maxMOI*nloci)
allelesf = matrix(NA,nids,maxMOI*nloci)
mindistance = matrix(NA,nids,nloci)
alldistance = array(NA,c(nids,nloci,maxMOI*maxMOI))

## read in allele data into usable R objects (arrays)

for (j in 1:nloci) {
  locus = locinames[j]
  locicolumns = grepl(paste0(locus, "_"), colnames(genotypedata_latefailures))
  
  oldalleles = as.matrix(genotypedata_latefailures[, locicolumns])
  oldalleles = apply(oldalleles, 2, as.numeric)  # numeric conversion
  
  day0_rows = grepl("Day 0", genotypedata_latefailures$Sample.ID)
  dayf_rows = grepl("Day Failure", genotypedata_latefailures$Sample.ID)
  
  # Assign to alleles matrices
  alleles0[, (maxMOI*(j-1)+1):(maxMOI*(j-1) + ncol(oldalleles))] = oldalleles[day0_rows, , drop=FALSE]
  allelesf[, (maxMOI*(j-1)+1):(maxMOI*(j-1) + ncol(oldalleles))] = oldalleles[dayf_rows, , drop=FALSE]
}


number_matches = rep(NA,nids)
match_output = matrix("",nids*2,nloci)
colnames(match_output) = locinames
number_loci = rep(NA, nids)
## count matches
for (i in 1:nids) {
  nmatches_temp = 0
  nloci_temp = 0
  for (j in 1:nloci) { # determine which alleles are recrudescing (for beginning, choose closest pair)
    allpossiblerecrud = expand.grid(1:MOI0[i],1:MOIf[i])
    if (sum(!is.na(alleles0[i,(maxMOI*(j-1)+1) : (maxMOI*(j-1) + MOI0[i])])) > 0 & sum(!is.na(allelesf[i,(maxMOI*(j-1)+1) : (maxMOI*(j-1) + MOIf[i])])) > 0){
      nloci_temp = nloci_temp+1
      
      closestrecrud = which.min(sapply(1:dim(allpossiblerecrud)[1], function (x) abs(alleles0[i,maxMOI*(j-1)+allpossiblerecrud[x,1]] - allelesf[i,maxMOI*(j-1)+allpossiblerecrud[x,2]])))
      mindistance[i,j] = abs(alleles0[i,maxMOI*(j-1)+allpossiblerecrud[closestrecrud,1]] - allelesf[i,maxMOI*(j-1)+allpossiblerecrud[closestrecrud,2]])
      if (mindistance[i,j] <= bin_sizes[j])
      {
        nmatches_temp=nmatches_temp+1
        match_output[2*(i-1)+1,j] = "R"
      } else {
        match_output[2*(i-1)+1,j] = "NI"
      }
    } else {
      match_output[2*(i-1)+1,j] = "IND"
    }
  }
  number_matches[i]=nmatches_temp
  number_loci[i] = nloci_temp
}

```


```{r output}

output_table = cbind(genotypedata_latefailures,match_output,"Number of Matches" = c(rbind(number_matches, rep("",nids))),"Number of loci" = c(rbind(number_loci, rep("",nids))), "Prob. of recrudescence" = probability_of_recrudescence_correctorder_formatted)
output_table[is.na(output_table)]=""

# formatting loci columns 
temp = sapply(colnames(genotypedata_latefailures)[-c(1,2)],function(x) strsplit(x,"_")[[1]][1])
column_breaks_dark = c((which(temp[1:(length(temp)-1)] != temp[2:length(temp)]))+3,length(temp)+3)

firstrow_labels = (c(" ", " ",column_breaks_dark[1]-3, diff(column_breaks_dark),nloci,2,1))
names(firstrow_labels) = c("","",locinames,"Individual marker calls","Counting","Bayesian")


finaltable = kbl(output_table, caption = "Table. Final classification of recrudescence versus new infection", escape=FALSE, table.attr="id=finaltable") %>%
  kable_styling(bootstrap_options = "striped", font_size = 10, full_width = TRUE) %>%
  column_spec((dim(output_table)[2] - nloci-2):dim(output_table)[2], bold = T) %>%
  add_header_above(firstrow_labels) %>%
  column_spec(column_breaks_dark, border_left = T) %>%
    column_spec(dim(output_table)[2], background = ifelse(probability_of_recrudescence_correctorder2 < 0.5 & probability_of_recrudescence_correctorder2>=0, "#58D68D", ifelse(probability_of_recrudescence_correctorder2 >=0.5,"#EDBB99","#ffffff00"))) %>%

  column_spec(1, border_left = T) %>%
  column_spec(3, border_left = T) %>%
  column_spec(column_breaks_dark[length(column_breaks_dark)]+nloci, border_left = T) %>%
  column_spec(column_breaks_dark[length(column_breaks_dark)]+nloci+2, border_left = T) %>%
  row_spec(seq(from=0,by=2,to = dim(output_table)[1]), extra_css = "border-bottom: 1px solid black") %>%

#  add_indent(c(3:5,7:12), level_of_indent = 1, all_cols = FALSE) %>%
  footnote(general="NI: New Infection; R: Recrudescence; IND: Indeterminate",general_title="")

write.csv(output_table ,"classification_output_table.csv")
finaltable
```



